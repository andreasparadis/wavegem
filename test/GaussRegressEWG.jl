# Load necessary modules
using Plots, LaTeXStrings, LinearAlgebra, DelimitedFiles
using FFTW.AbstractFFTs, DSP, Statistics, BSplineKit
using CurveFit: linear_fit
import ColorSchemes.darkrainbow

gr(fontfamily = "Computer Modern", titlefont = (11, "New Century Schoolbook Bold"))
cb = darkrainbow

# Include necessary scripts for functions
include("text_process.jl"); include("signal_processing.jl")
include("peak_detect.jl");  include("runge_kutta.jl")
include("Gauss_Reg_t.jl");  include("directories.jl")
include("wave_theory.jl");  include("jonswap.jl")

#############################################################################################
# INPUTS
## Case directory
# case_dir = joinpath("UCL","Waves","HS006TP1TR128","Random")
case_dir = joinpath("SE","LCH","1")
# case_dir = joinpath("JFM")
# case_dir = joinpath("JFM","EV_2")

## Event directory
# evdir = "EV5"
# evdir = "Surge_EV4"
evdir = "MaxFair_10"
# evdir = "MaxCoM"

## Event filename of 1st order elevation
fid_ev = "event_lin" # File name

#############################################################################################
# IO directories
libpath = joinpath(pwd(),"library") # Project's library folder
Parent = joinpath(libpath,case_dir)
Decpath = joinpath(Parent,"Decomposition")
DecFigs = joinpath(Decpath,"Figures")
Eventpath = joinpath(Decpath,evdir)
fid_res = joinpath(Eventpath,"GR_Results")  
fid = joinpath(Eventpath,fid_ev) # Path to event file

if !isdir(fid_res)
    mkdir(fid_res)
end

# Read simulation parameters from file
fpar = joinpath(Decpath,"sim_pars")
cont = parse_fxw(fpar, 1)  
H‚Çõ, T‚Çö, Tcut = cont[1], cont[2], cont[4]
fcut = 1/Tcut
#############################################################################################
## Global variables
g::Float64 = 9.81
d::Float64 = 100
# H‚Çõ, T‚Çö, Œ≥, fcut, d::Float64 = 0.054, 1.024, 3.3, 4.0, 1.0
# H‚Çõ, T‚Çö, fcut, d::Float64 = 0.069, 1.0, 4.0, 1.0  
# Tcut = 1/fcut

### TRUNCATION
# false ‚â° From 1st to last upcrossing, true ‚â° Specific number of upcrossings prior and after highest peak
ftrunc = false
pNuc = 4;   aNuc = 2    # Relevant only for true

### ENVELOPE LOW-PASS FILTER
fcÀ°·µñ = 0.5*fcut # Cut-off frequency

### ENVELOPE PEAK DETECTION
std_fac = 2 # MinPeakVal - std coeff (1.25: >Œ∑ÃÖ, 2: >H‚Çõ/2, 0: all)
MinPeakDist = 2*Tcut

### RK SOLUTION PARAMETERS
œµ = 1e-5        # Accuracy
NœÑ = Int(1e4)   # Max iterations
dœÑ = 1e-1       # Step of fictitious time
Tlb = 0*Tcut    # Constraint - Lower bound 
Tub = 250        # Constraint - Higher bound

## Flags
frec = true    # Write output files

## Semi-submersible FOWT eigenfrequencies
T‚ÇÄ‚Çõ¬π, T‚ÇÄ‚Çõ¬≤, T‚ÇÄ‚Çï, T‚ÇÄ‚Çö = 250.0000, 35.714107, 17.543772, 27.026892   

#############################################################################################
# Pre-processing of wave event
## Read event surface elevation from file
cont = parse_fxw(fid, 0)

t·µ¢ = (cont[:,1] .- cont[1,1]) # initial time vector
Œ∑·µ¢ = cont[:,2] # Surface elevation
L·µ¢ = length(t·µ¢)

## Shift zero time at highest peak
Œ∑HP = findmax(Œ∑·µ¢)[1]   # Œ∑ = Œ∑ ./ Œ∑HP
iHP = findmax(Œ∑·µ¢)[2]
t = t·µ¢ .- t·µ¢[iHP]     

# Truncate event based on number of up-crossings before and after highest peak
iD·µ§ = findall(diff(sign.(Œ∑·µ¢)) .== 2) # Up-crossings of surface elevation
LiD·µ§ = length(iD·µ§)

istart, iend = Int(0), Int(0)
cnt = Int(iHP - minimum(abs.(iHP.-iD·µ§)))

if ftrunc
    # Select based on No of up-crossings before and after
    for i ‚àà 1:LiD·µ§
        if iD·µ§[i] == cnt
            icnt = i
            global istart = iD·µ§[icnt-pNuc]
            global iend = iD·µ§[icnt+aNuc]
        end
    end
else
    # From 1st to last upcrossing
    global istart = iD·µ§[1]
    global iend = iD·µ§[LiD·µ§]
end

## Truncate event
t = t[istart:iend]
Œ∑ = Œ∑·µ¢[istart:iend]
M = length(t);      √ò·¥π = zeros(Float64,M) 
dt = (t[end]-t[1])/(M-1)

## Event spectral analysis and peak frequency
fr_Œ∑, mag_Œ∑, œï_Œ∑,_ = one_side_asp(Œ∑, t)
f·µâ‚Çö = fr_Œ∑[findmax(mag_Œ∑)[2]]

#############################################################################################
# Hilbert transform and envelope of surface elevation
ùìó = hilbert(Œ∑);        u·µ¢ = abs.(ùìó)

# Low-pass filtering of envelope
f‚ÇõÀ°·µñ = round(1/dt)
Ntaps = nextpow(2,f‚ÇõÀ°·µñ/fcÀ°·µñ)   # No of taps
u = low_pass_filter(u·µ¢,fcÀ°·µñ,f‚ÇõÀ°·µñ,Ntaps)

# Peak detection based on 2nd derivative of signal
MinPeakVal = std_fac*std(Œ∑) 
A, t·∂ú, i‚Å∫, u‚Çú, u‚Çú‚Çú = peaks_max_ext(u,t, MinPeakVal, MinPeakDist)

#############################################################################################
# Up- and down-crossings
iDue = findall(diff(sign.(u.-MinPeakVal)) .== 2) # Up-crossings of envelope
iDde = findall(diff(sign.(u.-MinPeakVal)) .== -2) # Down-crossings of envelope

TIE, TDE, Tz = [0], [0], 0
if length(iDue) > 1
    TIE = [abs(t[iDue[i]] - t[iDue[i+1]]) for i ‚àà 1:length(iDue)-1]
    TDE = [abs(t[iDue[i]] - t[iDde[i]]) for i ‚àà 1:length(iDue)]
    Tz = mean(TIE)
else
    Tz = TIE
end
TD = (t[end]-t[1])
#############################################################################################
# Perform the least squares fitting
## Initial condition for L based on ‚àÇ‚Çú¬≤g(t·∂ú) = ‚àÇ‚Çú¬≤u(t·∂ú)
N = length(t·∂ú)     
√ò·¥∫ = zeros(Float64,N);  √ò = Array{Float64}(undef,0)
T = √ò·¥∫

for n ‚àà 1:N
    i = i‚Å∫[n]
    if u‚Çú‚Çú[i] < 0 
        T[n] = sqrt.(-2*A[n]./u‚Çú‚Çú[i])
    else
        T[n] = sqrt.(2*A[n]./u‚Çú‚Çú[i])
    end
end

# Definition of the ODE's dL‚Çò 
œÑ = zeros(Float64,NœÑ)
[œÑ[i] = (i-1)*dœÑ for i ‚àà 2:NœÑ]
println("œÑ‚Çë = ", œÑ[end])
fun(œÑ,T) = dLdœÑ(œÑ,T, t, A, t·∂ú,u, dt)

# Solve optimization problem
T‚Çí‚Çö‚Çú = RK4_nln_sys(œÑ,T,fun,Tlb,Tub,œµ)

# Optimal values
T‚Çí, A‚Çí, t·∂ú‚Çí = [√ò[:] for _ = 1:3]
i‚Å∫‚Çí = Array{Int64}(undef,0)
pltCONV = plot(palette=:darkrainbow)

for n ‚àà 1:N
    plot!(pltCONV, T‚Çí‚Çö‚Çú[2][:,n], xlab = "Iteration",  ylab = L"T_o^i [s]", xscale=:log10, lab = "To[$(n)]", lw=2, legend=:outerbottom, legendcolumns=N)
    if T‚Çí‚Çö‚Çú[1][n] > Tcut
        push!(T‚Çí, T‚Çí‚Çö‚Çú[1][n])
        push!(A‚Çí, A[n])
        push!(t·∂ú‚Çí, t·∂ú[n])
        push!(i‚Å∫‚Çí,i‚Å∫[n])
    end
end

lenT = length(T‚Çí)

#############################################################################################
# Resulting Gaussian approximation of the envelope
G = gauss_fun(t, A‚Çí, t·∂ú‚Çí, T‚Çí)

# Propagation of resulting WGs
Œ∏ = angle.(ùìó)       # Œ∏ = œï-œât
eŒ∏ = exp.(1im*Œ∏)     # exp(iŒ∏) = exp(-iœât)*exp(iœï)
# Œ∑‚Çú = G.*eŒ∏

## Instantaneous frequency
omH = zeros(Float64, M)
Œ∏·µ§ = unwrap(Œ∏)
for i ‚àà 2:M-1
    omH[i] = (Œ∏·µ§[i+1] - Œ∏·µ§[i-1]) / (t[i+1]-t[i-1])
end

frH, mgH, angH, _,_ = one_side_asp(omH,t)

œâ‚Çí = 2œÄ ./ T‚Çí
œâ·µ¢ = zeros(Float64, lenT)
Œ≤·µ¢ = zeros(Float64, lenT)
Œ≤‚Çí = zeros(Float64, lenT)

for n ‚àà 1:lenT
    eœï·µ¢ = eŒ∏ .* exp.(1im*œâ‚Çí[n]*t)           # exp(iœï) = exp(iŒ∏)/exp(-iœât) = exp(iŒ∏)*exp(iœât)
    œï·µ¢ = real(-1im*log.(eœï·µ¢))
    œï·µ¢·µ¢ = unwrap(œï·µ¢)
    # œâ·µ¢[n] = (œï·µ¢·µ¢[end]-œï·µ¢·µ¢[1])/(t[end]-t[1])
    local fit = linear_fit(t,œï·µ¢·µ¢)
    œâ·µ¢[n] = fit[2]    # œï = œâ‚Å∫*t + Œ≤
    Œ≤·µ¢[n] = fit[1]

    n·µ¶ = Int(round((t·∂ú‚Çí[n]-t[1])/dt + 1))
    Œ≤‚Çí[n] = œï·µ¢·µ¢[n·µ¶]
    # Œ≤‚Çí[n] = œâ·µ¢[n]*t·∂ú‚Çí[n]+Œ≤·µ¢[n]
end

œâÃÉ = (œâ·µ¢.-œâ‚Çí)[1]
Œ≤ÃÉ = (Œ≤·µ¢.-Œ≤‚Çí)

eœât = sum(exp.(-1im*œâ‚Çí[n]*t) for n ‚àà 1:lenT)    # exp(-iœât) = ‚àëexp(-iœâ‚Çôt)
# eœât = eœât ./ maximum(real(eœât))
œât = unwrap(real(-1im*log.(eœât)))
f‚Å∫·µ¢ = œâ·µ¢/2/œÄ
T‚Å∫·µ¢ = 1/f‚Å∫·µ¢

eœï = eŒ∏ ./ eœât
œï = real(-1im*log.(eœï))
fit = linear_fit(t,unwrap(œï))
œâ‚Å∫ = fit[2]    # œï = œâ‚Å∫*t + Œ≤ ‚â° mean(œâ·µ¢)
Œ≤ = fit[1]     # ‚â° mean(Œ≤·µ¢)
f‚Å∫ = œâ‚Å∫/2/œÄ
T‚Å∫ = 1/f‚Å∫

eœïÃÉ = exp.(1im*(œâ‚Å∫*t .+ Œ≤))
eŒ∏ÃÉ = exp.(1im*(œâÃÉ*t .+ Œ≤ÃÉ[1]))
# eŒ∏ÃÉ = exp.(1im*(œâ‚Å∫*t .+ Œ≤)) .* exp.(1im*œât)
# eŒ∏ÃÉ = exp.(1im*(œâ‚Å∫*t .+ Œ≤)) .* eœât
Œ∑‚Çú = G.*real(eŒ∏ÃÉ)

#############################################################################################
# Normalization
œâ‚Çö = 2œÄ/T‚Çö
Œ© = œâÃÉ/œâ‚Çö;      œâÃÖ‚Å∫ = œâ‚Å∫/œâ‚Çö;      œâÃÖ·µ¢ = œâ·µ¢./œâ‚Çö
GÃÖ = G ./ maximum(u)
tÃÖ = t ./ T‚Çö
TÃÖz = Tz / T‚Çö    
TÃÖIE = TIE ./ T‚Çö;   TÃÖDE = TDE ./ T‚Çö
TÃÖ‚Çí = T‚Çí ./ T‚Çö;     AÃÖ‚Çí = A‚Çí ./ H‚Çõ;     tÃÖ·∂ú = t·∂ú‚Çí ./ T‚Çö

tÃÖ‚Çò = zeros(Float64, lenT)   # Peak times based on envelope intervals (from up-crossings)
tÃÖ‚Çò[1] = -TÃÖIE[1]
if length(TIE) > 1
    for n ‚àà 1:length(TIE)-1
        tÃÖ‚Çò[n+1] = tÃÖ‚Çò[n] + TÃÖIE[n]
    end
end

#############################################################################################
# Propagation of individual EWGs
TOT = zeros(ComplexF64, M)  # Total surface elevation
N‚Çõ = Int(nextpow(2,M)/2)
SP_TOT = zeros(Float64, N‚Çõ) # Total spectrum of propagated Gaussian EWGs

plt_gn = plot(palette=:darkrainbow)
pltEWG = plot(palette=:darkrainbow)
pltSPEC = plot(palette=:darkrainbow)

for n ‚àà 1:lenT  
    # Propagated EWG - Focused WG
    g‚Çô, Œ∑·∂ú, Œ∑‚Çô, FR, MAG = recon(0, AÃÖ‚Çí[n], tÃÖ·∂ú[n], TÃÖ‚Çí[n], Œ≤ÃÉ[n], H‚Çõ, T‚Çö, Œ©, t)

    TOT[:] = TOT[:] .+ Œ∑‚Çô
    SP_TOT[:] = SP_TOT[:] .+ MAG

    plot!(plt_gn, tÃÖ*T‚Çö, g‚Çô, xlab = "t [s]", ylab = "A [m]", lab = "g$(n)", lw=2, legend=:outerbottom, legendcolumns=lenT)
    plot!(pltEWG, tÃÖ*T‚Çö, real(Œ∑‚Çô), xlab = "t [s]", ylab = "Œ∑ [m]", lab = "Œ∑$(n)", lw=2, legend=:outerbottom, legendcolumns=lenT)
    plot!(pltSPEC, FR, MAG, xlab = L"f [Hz]", ylab = L"A [m^2 s]", lab = "g$(n)", lw=2, legend=:outerbottom, legendcolumns=lenT)                            

    fid_EWG = joinpath(fid_res,"EWG_$n") # File name
    open(fid_EWG, "w")
    # writedlm(fid_EWG, [round.(t*1e6)./1e6 round.(g‚Çô*1e6)./1e6 round.(real(Œ∑‚Çô*1e6))./1e6 round.(angle.(Œ∑‚Çô)*1e6)./1e6], '\t')
    writedlm(fid_EWG, [round.(t*1e6)./1e6 round.(g‚Çô*1e6)./1e6 round.(Œ∑‚Çô*1e6)./1e6], '\t')
end

#############################################################################################
# PLOTS
# Signal and initial envelope
plt_sigenv = plot(xlab=L"t~[s]", ylab=L"[m]", palette=[cb[11];cb[4];cb[8]])
plot!(t, [Œ∑ u·µ¢], lab=[L"Œ∑(t)" L"u(t)"], lw=[2 2])
plot!(t, MinPeakVal*ones(Int,M), lab="$std_fac std(Œ∑)", line=:dash)

# Filtered vs initial envelope
plt_env = plot(xlab=L"t~[s]", ylab=L"[m]", palette=[cb[11];cb[4];cb[8]])
plot!(t, [u·µ¢ u], lab=[L"u(t)" L"u_{flt}(t)"], lw=[2 2], line=[:solid :dashdot])
# plot!(t, [u·µ¢ u·µ¢·µ¢ u], lab=[L"u(t)" L"u_{ii}(t)" L"u_{flt}(t)"], lw=[2 2 2], line=[:solid :solid :solid])
# plot!(t, std_fac_u*std(u·µ¢·µ¢)*ones(Int,M), lab="$std_fac_u std(u)", line=:dash)
plot!(t, MinPeakVal*ones(Int,M), lab="$std_fac std(Œ∑)", line=:dash)
# plot!(t, MinPeakVal*ones(Int,M), lab=L"H_s/2", line=:dash)

# Gaussian approximation against envelope and scatter plot of peaks
plt_G = plot(xlab = L"t~[s]", ylab = L"[m]", palette=[cb[4];cb[8];cb[11]], legend=:outertop, legendcolumns=4)
plot!(t, [u real(G)], lab = [L"u_{flt}(t)" L"G(t)"], lw=[2 2])
plot!(t, MinPeakVal*ones(Int,M), lab="$std_fac std(Œ∑)", line=:dash)
# plot!(t, MinPeakVal*ones(Int,M), lab=L"H_s/2", line=:dash)
plot!(t·∂ú, A, seriestype=:scatter, ms=2, mc=:red, lab = "Peaks")

# Plot EWGs
# plot!(pltEWG, t, Œ∑, lab = L"\eta(t)",lw=2, line=:dot)
plot!(pltSPEC, xlim=(0,fcut))

# Plot original and reconstructed signals
plt_eta0 = plot(xlab=L"t~[s]", ylab=L"\eta ~[m]", palette=[cb[11];cb[4]]) 
plot!(t, Œ∑, lab = L"\eta(t)",lw=2)
plot!(t, real(Œ∑‚Çú), lab=L"\eta_G(t)", lw=2, line=:dot)

plt_eta1 = plot(xlab=L"t~[s]", ylab=L"\eta ~[m]", palette=[cb[11];cb[8]]) 
plot!(t,Œ∑, lab = L"\eta(t)",lw=2)
plot!(tÃÖ*T‚Çö, real(TOT), lab = L"\sum EWGs", lw=2, line=:dot)

plt_eta2 = plot(xlab=L"t~[s]", ylab=L"\eta ~[m]", palette=[cb[4];cb[8]]) 
plot!(t, real(Œ∑‚Çú), lab=L"\eta_G(t)", lw=2, line=:dot)
plot!(tÃÖ*T‚Çö, real(TOT), lab = L"\sum EWGs", lw=2)

# Spectra of resulting signals
plt_spec = plot(palette=[cb[11];cb[4];cb[8];cb[1]], legend=:topright)
plot!(fr_Œ∑, mag_Œ∑, xlab = "f [Hz]", ylab = L"A [m^2 s]", lab = "Original", lw=2)
freq, mag, _ = one_side_asp(real(Œ∑‚Çú), t)
plot!(freq, mag, xlab = "f [Hz]", ylab = L"A [m^2 s]", lab = L"\eta_{new}", lw=2)
freq, mag, _ = one_side_asp(real(TOT), tÃÖ*T‚Çö)
plot!(freq, mag, xlab = "f [Hz]", ylab = L"A [m^2 s]", lab = "Sum", lw=2, line=:dot)
plot!(freq, SP_TOT, xlab = "f [Hz]", ylab = L"A [m^2 s]", lab = "SP_TOT", lw=2, line=:dashdot)
plot!(xlim=(0,fcut))

# Plot the group parameters in ascending order
plt_pars = plot(xlab = L"T_o~[s]", ylab = L"A_o~[m]")
plot!(T‚Çí, A‚Çí, seriestype=:scatter, ms=2, mc=:red, lab = "Group parameters (sorted)")

# Normalized envelope
plt_GÃÖ = plot(tÃÖ, GÃÖ)
plot!(plt_GÃÖ, xlab=L"t/T_p~[-]", ylab=L"\overline{G} = G/u_{max}~[-]")

plt_ang_un = plot(xlab=L"t/T_p", ylab=L"\angle ~[rad]", palette=[cb[11];cb[4];cb[8]])
plot!(plt_ang_un, tÃÖ, Œ∏·µ§, lab=L"\theta (t)", lw=2)
plot!(plt_ang_un, tÃÖ, œâ‚Å∫*t .+ Œ≤ .+ œât, lab=L"\theta_{cal} (t)", lw=2)
plot!(plt_ang_un, tÃÖ, œâ‚Å∫*t .+ Œ≤, lab=L"\phi_{cal} (t)", line=:dash)
plot!(plt_ang_un, tÃÖ, -œât, lab=L"œât_{cal} (t)", line=:dash)

plt_ang = plot(xlab=L"t/T_p", ylab="Temporal term ~[-]", palette=[cb[11];cb[4];cb[8]])
plot!(plt_ang, tÃÖ, real(eŒ∏), lab=L"Re\{e^{\theta (t)}\}", lw=2)
plot!(plt_ang, tÃÖ, real(eŒ∏ÃÉ), lab=L"Re\{e^{\theta_{cal} (t)}\}", lw=2)
plot!(plt_ang, tÃÖ, real(eœïÃÉ), lab=L"Re\{e^{\phi_{cal} (t)}\}", line=:dash)
plot!(plt_ang, tÃÖ, real(exp.(1im*œât)), lab=L"Re\{e^{œât_{cal} (t)}\}", line=:dash)

plot!(pltCONV,xlim=(1e1,1e5))

# Display plots
display(plt_sigenv)
display(plt_env)
display(plt_G)
display(plt_gn)
display(pltEWG)
display(pltSPEC)
display(plt_eta0)
display(plt_eta1)
display(plt_eta2)
display(plt_spec)
display(plt_pars)
display(plt_GÃÖ)
display(plt_ang_un)
display(plt_ang)
display(pltCONV)

etaG = zeros(Float64, L·µ¢)
etaG[istart:iend] = real(Œ∑‚Çú)[:]
plot(t·µ¢, Œ∑·µ¢, lw=2, lab=L"\eta (t)")
# plot!(t·µ¢,etaG, lw=2, lab=L"G (t)")

EWGsum = zeros(Float64, L·µ¢)
EWGsum[istart:iend] = real(TOT)[:]
display(plot!(t·µ¢,EWGsum, lw=2, lab=L"\sum g_i (t)"))

Œ∑TOT = fcsd_wg(freq, SP_TOT, t, A‚Çí[1], 0, Œ≤ÃÉ[1])
etaFCSD = zeros(Float64, L·µ¢)
etaFCSD[istart:iend] = Œ∑TOT[:]
# display(plot!(t·µ¢, etaFCSD, lw=2, lab="Focused wave"))

# Save figures
fid = joinpath(fid_res,"envelope")
savefig(plt_sigenv, fid*".svg");  savefig(plt_sigenv, fid*".png")
fid = joinpath(fid_res,"env_Ginterp")
savefig(plt_G, fid*".svg");  savefig(plt_G, fid*".png")
fid = joinpath(fid_res,"EWGs")
savefig(pltEWG, fid*".svg");    savefig(pltEWG, fid*".png")
fid = joinpath(fid_res,"new_sig_comp")
savefig(plt_eta0, fid*".svg");   savefig(plt_eta0, fid*".png")
fid = joinpath(fid_res,"EWGpars")
savefig(plt_pars, fid*".svg");   savefig(plt_pars, fid*".png")

#############################################################################################
if frec
    # Write results in text files
    t = round.(t*1e6)./1e6
    Œ∑‚Çú = round.(Œ∑‚Çú*1e6)./1e6
    TOT = round.(TOT*1e6)./1e6
    t·∂ú‚Çí = round.(t·∂ú‚Çí*1e6)./1e6
    A‚Çí = round.(A‚Çí*1e6)./1e6
    T‚Çí = round.(T‚Çí*1e6)./1e6

    fid = joinpath(fid_res,"etaG")
    open(fid, "w")
    writedlm(fid, [t·µ¢ etaG], '\t')
    # writedlm(fid, [t real(Œ∑‚Çú) angle.(Œ∑‚Çú)], '\t')

    fid = joinpath(fid_res,"EWGsum")
    open(fid, "w")
    writedlm(fid, [t·µ¢ EWGsum], '\t')
    # writedlm(fid, [t real(TOT) angle.(TOT)], '\t')

    fid = joinpath(fid_res,"etaFCSD")
    open(fid, "w")
    writedlm(fid, [t·µ¢ etaFCSD], '\t')

    fid = joinpath(fid_res,"EWGpars")
    head = ["t·∂ú‚Çí [s]" "T‚Çí [s]" "A‚Çí [m]"]
    open(fid, "w")
    writedlm(fid, [head; t·∂ú‚Çí T‚Çí A‚Çí], '\t')    

    fid = joinpath(fid_res,"EWG_norm_pars")
    # head = ["tÃÖ·∂ú [-]" "TÃÖ‚Çí [-]" "AÃÖ‚Çí [-]" "Œ≤·µ¢ [rad]" "œâÃÖ·µ¢ [-]" "TÃÖDE [-]" "tÃÖ‚Çò"]
    head = ["tÃÖ·∂ú [-]" "TÃÖ‚Çí [-]" "AÃÖ‚Çí [-]" "Œ≤ÃÉ [rad]" "œâÃÖ·µ¢ [-]" "TÃÖ‚Çõ" "TÃÖ‚Çï" "TÃÖ‚Çö"]
    open(fid, "w")
    # row = round.([tÃÖ·∂ú TÃÖ‚Çí AÃÖ‚Çí Œ≤ÃÉ œâÃÖ·µ¢ TÃÖDE tÃÖ‚Çò]*1e6)./1e6
    row = round.([tÃÖ·∂ú TÃÖ‚Çí AÃÖ‚Çí Œ≤ÃÉ œâÃÖ·µ¢ T‚Çí./T‚ÇÄ‚Çõ¬≤ T‚Çí./T‚ÇÄ‚Çï T‚Çí./T‚ÇÄ‚Çö]*1e6)./1e6
    writedlm(fid, [head; row], '\t')

    fid = joinpath(fid_res,"G_pars")
    head = ["H‚Çõ [m]" "T‚Çö [s]" "Œ© [-]" "Œ≤ [rad]" "$std_fac*œÉ‚Çô" "Œ∑‚Çò‚Çê‚Çì [m]" "u‚Çò‚Çê‚Çì [m]" "tÃÖ‚Çë·µ• [-]" "œâÃÖ‚Å∫ [-]" "TÃÖz [-]"]
    open(fid, "w")
    row = round.([H‚Çõ T‚Çö Œ© Œ≤ MinPeakVal Œ∑HP maximum(u) tÃÖ[end]-tÃÖ[1] œâÃÖ‚Å∫ TÃÖz]*1e6)./1e6
    writedlm(fid, [head; row], '\t')
end